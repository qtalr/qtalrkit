---
title: "Web scraping with R"
bibliography: [bibliography.bib, packages.bib]
biblio-style: apalike
link-citations: true
pkgdown:
  as_is: true
---

```{r, child="_common.Rmd"}
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## Orientation

To provide an example of the curation process using semi-structured data, we will work with the Federalist Papers data acquired from a web scrape of the Library of Congress website in @sec-acquire-data. The data is stored in a series of HTML files, as seen in @exm-cd-federalist-data-files.

::: {#exm-cd-federalist-data-files}
```bash
data/
├── analysis/
├── derived/
└── original/
    │── fed_papers_do.csv
    └── federalist_papers/
        ├── main.html
        ├── text-1-10.html
        ├── text-11-20.html
        ├── text-21-30.html
        ├── text-31-40.html
        ├── text-41-50.html
        ├── text-51-60.html
        ├── text-61-70.html
        ├── text-71-80.html
        └── text-81-85.html
```
:::

Our data origin file, *fed_papers_do.csv* in @tbl-cd-fed-data-origin, gives us an overview of the data.

```{r}
#| label: tbl-cd-fed-data-origin
#| tbl-cap: "Data origin file for the Federalist Papers dataset."
#| echo: false

read_csv("data/original/fed_papers_do.csv") |> 
  kable() |> 
  kable_styling()
```

From the file structure and the data origin description, we can surmise that we are working with HTML files which will contain the 85 Federalist Papers. The 85 papers are grouped into 9 files, meaning that for each file there will be multiple papers contained within. We can also see that the HTML files are named according to the range of papers contained within each file. For example, the *text-1-10.html* file contains the first 10 papers.

It is also a good idea to inspect the data files themselves. Since these are HTML files, we can open them in a web browser. @fig-cd-federalist-html shows the *text-1-10.html* file opened in a web browser.

```{r}
#| label: fig-cd-federalist-html
#| fig-cap: "The *text-1-10.html* file opened in a web browser."
#| echo: false

knitr::include_graphics("assets/images/guide-7/fed-papers-text-1-10.png")
```

At this point we want to think about what our curated dataset will look like in terms of rows and columns. For the columns, it is helpful to think about what variables we can extract from each of the Federalist Papers. For example, we can extract the paper number, the paper title, the paper's author(s), the venue in which the paper was published, and the paper's text. Of these variables, the paper number, title, and author(s) are metadata about the paper, while the venue is metadata about the publication of the paper, so we will leave venue out of our curated dataset.

For the rows, we can think about what the unit of analysis is. If we want to conduct a text analysis of the Federalist Papers to predict the author of the paper based on features of the text, then the unit of analysis will be the paper. Now, we can envision a case in which each row is a paper, but to may be the case that the structure of the papers, namely the paragraphs, could be of some use to us. We will keep this in mind as we work through the curation process.

With this information in mind, an idealized version of our curated dataset is shown in @tbl-cd-fed-data-idealized.

```{r}
#| label: tbl-cd-fed-data-idealized
#| tbl-cap: "Idealized version of the curated Federalist Papers dataset."
#| echo: false

tribble(
  ~number, ~title, ~author, ~text,
  "1", "...", "...", "...",
  "2", "...", "...", "...",
  "...", "...", "...", "...",
  "85", "...", "...", "..."
) |> 
  kable() |> 
  kable_styling()
```

## Tidy the data

The idealized dataset structure will guide our work. To extract the data and metadata from the files we will need to take a closer look at the structure of the HTML documents. We start with the HTML file we opened in a browser in @fig-cd-federalist-html and look at the HTML source code with the browser's inspect tool. @fig-cd-federalist-html-inspect shows the HTML source code for the first paper in the *text-1-10.html* file.

```{r}
#| label: fig-cd-federalist-html-inspect
#| fig-cap: "The HTML source code for the first paper in the *text-1-10.html* file."
#| echo: false

knitr::include_graphics("assets/images/guide-7/fed-papers-text-1-10-inspect-1.png")
```

The structure of the HTML files suggests that the desired content is within a `div` tag, which forms a kind of box around each paper. There are multiple `div` tags in the file, so we will need to find a way to identify the `div` tag that contains the desired content, and only this content. We can see that the `div` tag we want has two `class` attributes, `s-lib-box s-lib-box-std`. This `div` tag contains a `h2` tag where the paper number appears. The first `p` tag contains the title of the paper. The second `p` tag contains the venue for the paper. The third `p` tag contains the author of the paper. The remaining `p` tags contain the text of the paper. A closer view of the `div` tag is shown in @fig-cd-federalist-html-inspect-2.

```{r}
#| label: fig-cd-federalist-html-inspect-2
#| fig-cap: "A closer view of the `div` tag containing the first paper in the *text-1-10.html* file."
#| echo: false

knitr::include_graphics("assets/images/guide-7/fed-papers-text-1-10-inspect-2.png")
```

Let's read in the *text-1-10.html* file and use it as a testing ground for extracting the relevant information. Load the `rvest` package and read in the file with `read_html()`, as in @exm-cd-federalist-html.

::: {#exm-cd-federalist-html}
```{r}
#| label: cd-federalist-html-show
#| eval: false

# Load packages
library(rvest)

# Read in the file
fed_file <- "../data/original/federalist_papers/text-1-10.html"
fed_html <- read_html(fed_file)

# Preview
fed_html
```

```{r}
#| label: cd-federalist-html-run
#| echo: false

# Load packages
library(rvest) 
library(xml2)

# Read in the file
fed_file <- "data/original/fed_papers/text-1-10.html"
fed_html <- read_html(fed_file)

# Preview
fed_html
```
:::

Given what we discovered in the HTML inspection, let's extract the `div` tags with the `s-lib-box s-lib-box-std` class attributes. We can use the `html_elements()` function to extract the `div` tags and the append `.s-lib-box.s-lib-box-std` to the `html_elements()` function to specify the class attributes. @exm-cd-federalist-html-div shows the result assigned to an object called `fed_divs`.

::: {#exm-cd-federalist-html-div}
```{r}
#| label: cd-federalist-html-div

# Extract the div tags
fed_divs <- 
  fed_html |> 
  html_elements("div.s-lib-box.s-lib-box-std")

# Preview divs ()
fed_divs |> 
  html_attr("class")
```
:::

Using the `html_attr("class")` function we can see that the `fed_divs` object for this file contains 11 `div` tags, all the `div` tags we want, and one we don't which also includes the `s-lib-floating-box` class. We can exclude it by adding `:not(.s-lib-floating-box)` to the CSS selector. But it is worth checking out one or two other HTML files to see if this is a consistent pattern.

On inspection of other HTML files in our data, it turns out that only our first HTML file has the `.s-lib-floating-box` class. So a CSS solution might not be the way to go. An alternative, R-side solution is to use the `div.s-lib-box`, from above, and then subset the `fed_divs` vector to exclude the first element, which is where the extract `div` tag is located. @exm-cd-federalist-html-div-subset shows the result assigned to an object called `fed_divs`.

::: {#exm-cd-federalist-html-div-subset}
```{r}
#| label: cd-federalist-html-div-subset

# Extract the div tags
fed_divs <- 
  fed_html |> 
  html_elements("div.s-lib-box")

# Remove the first element
fed_divs <- fed_divs[-1]
```
:::

Assuming for the moment that the solution in @exm-cd-federalist-html-div-subset is the way to go, we can move forward to extract the paper number, title, author, and text from each `div` tag in `fed_divs`. We can use the `html_elements()` function to extract the `h2` tag, which contains the paper number, and later work with the `p` tags, which contain the title, author, and text.

We've already isolated the relevant `div` tags, so using the `fed_divs` object we can now continue to use the `html_elements()` function to extract HTML elements within. The paper number is in a `h2` tag, immediately after the `div` tag. We can use the `html_element()` function to extract a single `h2` tag for each `div` in `fed_divs`, as in @exm-cd-federalist-html-h2.

::: {#exm-cd-federalist-html-h2}
```{r}
#| label: cd-federalist-html-h2

# Extract the h2 tag
fed_h2 <- 
  fed_divs |> 
  html_element("h2")

# Preview
fed_h2
```
:::

The result is a vector which contains the `h2` tag for each `div` tag in `fed_divs`, complete with all the HTML tags and attributes. We can use the `html_text()` function to extract the text from the `h2` tag, as in @exm-cd-federalist-html-h2-text. 

::: {#exm-cd-federalist-html-h2-text}
```{r}
#| label: cd-federalist-html-h2-text

# Extract the text from the h2 tag
numbers <- 
  fed_divs |> 
  html_element("h2") |>
  html_text() |> 
  str_trim()

# Preview
numbers
```
:::

I included the `str_trim()` function from the `stringr` package to remove any potential whitespace from the text to the code in @exm-cd-federalist-html-h2-text. The result is a vector of the paper numbers, which we can later leverage to create a new column in our dataset.

Next, we can extract the `p` tags from the `fed_divs` object. The `p` tags contain the title, author, and text. As noted above, the first `p` tag inside each `div` tag contains the paper title. Targeting this `p` tag requires the use of a CSS selector, `:nth-child()`. This CSS selector allows us to arbitrarily select the `p` tag we want in the order it appears. In this case, we want the first `p` tag, so we can use `:nth-child(1)`. @exm-cd-federalist-html-p-title shows the result after extracting the text assigned to an object called `titles`.

::: {#exm-cd-federalist-html-p-title}
```{r}
#| label: cd-federalist-html-p-title

# Extract the title p tags
titles <- 
  fed_divs |> 
  html_elements("p:nth-child(1)") |> 
  html_text() |>
  str_trim()

# Preview
titles
```
:::

::: {.callout}
**{{< fa medal >}} Dive deeper**

CSS selectors are a powerful tool for extracting data from HTML files. The `:nth-child()` selector is just one of many. For more information on CSS selectors, see the [W3Schools CSS Selector Reference](https://www.w3schools.com/cssref/css_selectors.asp). The `rvest` package supports many, but not all CSS selectors. Consult the `rvest::html_elements()` documentation for more information. 
:::

We get a vector of length 13, not 10. Scanning the output we can see the most likely offender is the 'PUBLIUS.' text. We can exclude it by adding `:not(:contains("PUBLIUS."))` to the CSS selector, as in @exm-cd-federalist-html-p-title-subset.

::: {#exm-cd-federalist-html-p-title-subset}
```{r}
#| label: cd-federalist-html-p-title-subset

# Extract the title p tags
fed_divs |> 
  html_elements("p:nth-child(1):not(:contains('PUBLIUS.'))") |> 
  html_text() |>
  str_trim()
```
:::

That works, but this solution is 'brittle', meaning that it potentially overspecific and could easily break. For example, if the text of the title happens to include 'PUBLIUS.' it will be excluded. Furthermore, if the extra `p` tag contains some other text other than 'PUBLIUS.' it will be included. 

We can make the solution more robust by looking for a more general solution.  One possibility is to anchor the `p` tags to the `div` tag with the `.clearfix` class that appears directly above (`>`) the `p` tags we want, as in @exm-cd-federalist-html-p-title-subset-2.

::: {#exm-cd-federalist-html-p-title-subset-2}
```{r}
#| label: cd-federalist-html-p-title-subset-2

# Extract the title p tags
titles <- 
  fed_divs |> 
  html_elements("div.clearfix > p:nth-child(1)") |> 
  html_text() |>
  str_trim()

# Preview
titles
```
:::

Now we have our 10 titles. Moving on to the author, we would assume could use the same approach as above changing the `nth-child` argument to 3. However, inspecting the HTML reveals that the author is not always the third `p` tag, sometimes it is the second. What is consistent, however, is that the author is always preceded by the text 'Author:'. We can use the `:contains()` CSS selector to select the `p` tag that contains the text 'Author:'.

::: {#exm-cd-federalist-html-p-author}
```{r}
#| label: cd-federalist-html-p-author

# Extract the author p tags
authors <-
  fed_divs |>
  html_elements("div.clearfix > p:contains('Author:')") |>
  html_text() |>
  str_trim()

# Preview
authors
```
:::

With the result in @exm-cd-federalist-html-p-author, we have now been able to extract the paper number, title and author. Our dataset is taking shape, as we can appreciate in @tbl-cd-federalist-html-dataset-preview.

```{r}
#| label: tbl-cd-federalist-html-dataset-preview
#| tbl-cap: "Preview of the dataset after extracting the paper number, title, and author."
#| echo: false

# Preview of the dataset
tibble(
  number = numbers,
  title = titles,
  author = authors
) |> 
kable() |> 
kable_styling()
```

The last step is to extract the text of the paper. The contents of the papers are contained in the `p` tags that follow the `p` tag with the author. It would be nice to be able to target the `p` tags that follow the author `p` tag. However, there is no CSS selector that allows us to do this. An alternative is to read all the `p` tags in each `div.clearfix` tag and then select the `p` tags that follow the author `p` tag.

This approach requires an additional step. We need to conduct this process for each paper in the HTML file separate

the `str_which()` function to identify the index of the `p` tag that contains the author. We can then use the `str_subset()` function to select all the `p` tags that follow the author `p` tag.

::: {#exm-cd-federalist-html-p-text}
```{r}
#| label: cd-federalist-html-p-text
#| eval: false

# Extract the text p tags

```
:::


```{r}
#| label: extract-text-1

text <- 
  fed_divs[[1]] |> 
  html_elements("div.clearfix p:not(:contains('PUBLIUS'))") |> 
  html_text()

text <- text[-c(1:3)] # remove the first 3 elements

# Preview the first 2 elements
text[1:2] 
```

This gets the text for a single paper within a single `div` tag. We can wrap this in a function and apply it to each `div` tag.

```{r}
#| label: extract-text-2

library(purrr)

extract_text <- function(box) {
  text <- 
    box |> 
    html_elements("div.clearfix p:not(:contains('PUBLIUS'))") |> 
    html_text()
  
  return(text[-c(1:3)])
}

text <- 
  fed_divs |> 
  map(extract_text)
```

Now we can see what the text looks like for the first paper.

```{r}
#| label: extract-text-3

html_tbl <- 
  tibble(
  number = numbers,
  title = titles,
  author = authors,
  text = text
)

html_tbl |> 
  unnest(cols = text)
```

Putting these together for the first HTML file we get the following.

```{r}
#| label: function-extract-content

extract_content <- function(fed_file) {
  html <- read_html(fed_file)
  
  fed_divs <- 
    html |> 
    html_elements("div.s-lib-box")
  
  fed_divs <- fed_divs[-1]
  
  numbers <- 
    fed_divs |> 
    html_elements("h2") |> 
    html_text() |> 
    str_trim()
  
  titles <- 
    fed_divs |> 
    html_elements("div.clearfix > p:nth-child(1)") |> 
    html_text() |> 
    str_trim()
  
  authors <- 
    fed_divs |> 
    html_elements("div.clearfix > p:contains('Author:')") |>
    html_text() |> 
    str_trim()
  
  extract_text <- function(div) {
    text <- 
      div |> 
      html_elements("div.clearfix p:not(:contains('PUBLIUS'))") |> 
      html_text()
    
    return(text[-c(1:3)])
  }
  
  text <- 
    fed_divs |> 
    map(extract_text)

  html_tbl <-
    tibble(
      number = numbers,
      title = titles,
      author = authors,
      text = text
    )
  
  html_tbl <- 
    html_tbl |> 
    unnest(cols = text)

  return(html_tbl)
}
```

We can test this on the first HTML file.

```{r}
#| label: extract-content-test

extract_content(fed_file) |> 
  glimpse()
```

Let's try the fifth HTML file, just to make sure.

```{r}
#| label: extract-content-test-2

fed_file <- "data/original/fed_papers/text-51-60.html"

extract_content(fed_file) |> 
  glimpse()
```

Now we can apply this function to all the HTML files.

```{r}
#| label: extract-content-html-files

fed_files <- 
  dir_ls(path = "data/original/fed_papers/", regexp = "\\btext")

fed_tbl <-
  fed_files |> 
  map_df(extract_content)

glimpse(fed_tbl)
```

We can do some data checks to make sure we have the right number of rows and columns.

```{r}
#| label: data-checks

# Check the number of authors
fed_tbl |>
  group_by(author) |>
  summarize(author_count = n()) |>
  print(n = Inf)

fed_tbl |>
  group_by(number) |>
  summarize(number_count = n()) |>
  print(n = Inf)
```
